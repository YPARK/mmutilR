# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximate PCA
#'
#' @param mtx_file data file (feature x n)
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param row_weight_file row-wise weight file
#'
#' @return a list of (1) U (2) D (3) V
#'
#' @examples
#' ## Generate some data
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' .pc <- mmutilR::rcpp_mmutil_pca(dat$mtx, 3, TAKE_LN = FALSE)
#' .ind <- read.table(dat$indv)
#' .col <- unlist(read.table(dat$col))
#' .ind <- .ind[match(.col, .ind$V1), ]
#' plot(.pc$V[, 1], .pc$V[, 2], col = .ind$V2,
#'      xlab = "PC1", ylab = "PC2")
#' plot(.pc$V[, 2], .pc$V[, 3], col = .ind$V2,
#'      xlab = "PC2", ylab = "PC3")
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_pca <- function(mtx_file, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 10L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "") {
    .Call('_mmutilR_rcpp_mmutil_pca', PACKAGE = 'mmutilR', mtx_file, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file)
}

#' BBKNN(Batch-balancing kNN)-adjusted PCA
#'
#' @param mtx_file data file (feature x n)
#' @param r_batches batch names (n x 1)
#' @param knn kNN parameter k
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#'
#' @return a list of (1) U (2) D (3) V
#'
#' @examples
#' ## Generate some data
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' .ind <- read.table(dat$indv)
#' .col <- unlist(read.table(dat$col))
#' .ind <- .ind[match(.col, .ind$V1), ]
#' .bbknn <- mmutilR::rcpp_mmutil_bbknn_pca(dat$mtx,
#'                   .ind$V2, 10, 3, TAKE_LN = FALSE)
#' plot(.bbknn$V[, 1], .bbknn$V[, 2], col = .ind$V2,
#'      xlab = "PC1", ylab = "PC2")
#' plot(.bbknn$factors.adjusted[, 1], .bbknn$factors.adjusted[, 2],
#'      col = .ind$V2,
#'      xlab = "PC1 (BBKNN)", ylab = "PC2 (BBKNN)")
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#' 
rcpp_mmutil_bbknn_pca <- function(mtx_file, r_batches, knn, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 10L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "") {
    .Call('_mmutilR_rcpp_mmutil_bbknn_pca', PACKAGE = 'mmutilR', mtx_file, r_batches, knn, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file)
}

#' Annotate columns by marker feature information
#'
#' @param row_file row file
#' @param col_file column file
#' @param pos_labels markers
#' @param neg_labels anti-markers
#' @param qc_labels feature-specific threshold
#' @param mtx_file data file
#' @param param_kappa_max
#'
#' @return a list of inference results
#'
#' @examples
#' options(stringsAsFactors = FALSE)
#' ## combine two different mu matrices
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm.1 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.1[1:10, ] <- rgamma(5, 1, .1)
#' mm.2 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.2[11:20, ] <- rgamma(5, 1, .1)
#' mm <- cbind(mm.1, mm.2)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' rows <- read.table(dat$row)$V1
#' cols <- read.table(dat$col)$V1
#' ## marker feature
#' markers <- list(
#'   annot.1 = list(
#'     ct1 = rows[1:10],
#'     ct2 = rows[11:20]
#'   )
#' )
#' ## annotation on the MTX file
#' out <- mmutilR::rcpp_annotate_columns(dat$row, dat$col,
#'        mtx_file = dat$mtx, pos_labels = markers)
#' annot <- out$annotation
#' .pca <- mmutilR::rcpp_mmutil_pca(dat$mtx, 3, TAKE_LN = TRUE)
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' ## annotation on the PC results
#' out.2 <- mmutilR::rcpp_annotate_columns(dat$row, dat$col,
#'          pos_labels = markers,
#'          r_U = .pca$U, r_D = .pca$D, r_V = .pca$V)
#' annot <- out.2$annotation
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_annotate_columns <- function(row_file, col_file, pos_labels, r_neg_labels = NULL, r_qc_labels = NULL, mtx_file = "", r_U = NULL, r_D = NULL, r_V = NULL, KAPPA_MAX = 100., TAKE_LN = FALSE, BATCH_SIZE = 10000L, EM_ITER = 100L, EM_TOL = 1e-4, VERBOSE = FALSE, DO_STD = FALSE) {
    .Call('_mmutilR_rcpp_annotate_columns', PACKAGE = 'mmutilR', row_file, col_file, pos_labels, r_neg_labels, r_qc_labels, mtx_file, r_U, r_D, r_V, KAPPA_MAX, TAKE_LN, BATCH_SIZE, EM_ITER, EM_TOL, VERBOSE, DO_STD)
}

#' Merge multiple 10x mtx file sets into one set
#'
#' @param r_headers file set headers
#' @param r_batches unique batch names for each header
#' @param output output file header
#' @param nnz_cutoff number of non-zero cutoff for columns
#' @param delim delimiter in the column name
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' t1 <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "test1")
#' t2 <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "test2")
#' bats <- hdrs <- c("test1","test2")
#' t3 <- mmutilR::rcpp_merge_file_sets(hdrs, bats, "test3", 0)
#' A1 <- Matrix::readMM(t1$mtx);
#' rownames(A1) <- unlist(read.table(gzfile(t1$row)))
#' A2 <- Matrix::readMM(t2$mtx)
#' rownames(A2) <- unlist(read.table(gzfile(t2$row)))
#' A3 <- Matrix::readMM(t3$mtx)
#' rownames(A3) <- unlist(read.table(gzfile(t3$row)))
#' print(cbind(A1, A2))
#' print(A3)
#' unlink(list.files(pattern = "test1"))
#' unlink(list.files(pattern = "test2"))
#' unlink(list.files(pattern = "test3"))
#'
rcpp_merge_file_sets <- function(r_headers, r_batches, output, nnz_cutoff = 1, delim = "_") {
    .Call('_mmutilR_rcpp_merge_file_sets', PACKAGE = 'mmutilR', r_headers, r_batches, output, nnz_cutoff, delim)
}

#' Take a subset of rows and create a new MTX file-set
#'
#' @description For the new mtx file, empty columns with only zero
#'   elements will be removed.
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected row names
#' @param output output
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_simulate_poisson_data(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' rownames(Y) <- read.table(src.files$row)$V1
#' print(Y)
#' sub.rows <- sort(read.table(src.files$row)$V1[sample(10,3)])
#' print(sub.rows)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_copy_selected_rows(src.files$mtx,
#'                                               src.files$row,
#'                                               src.files$col,
#'                                               sub.rows,
#'                                               tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' rownames(Y) <- read.table(tgt.files$row)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_copy_selected_rows <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_mmutilR_rcpp_copy_selected_rows', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output)
}

#' Take a subset of columns and create a new MTX file-set
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected column names
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_simulate_poisson_data(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' colnames(Y) <- read.table(src.files$col)$V1
#' print(Y)
#' sub.cols <- sort(read.table(src.files$col)$V1[sample(20,3)])
#' print(sub.cols)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_copy_selected_columns(src.files$mtx,
#'                                      src.files$row,
#'                                      src.files$col,
#'                                      sub.cols, tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_copy_selected_columns <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_mmutilR_rcpp_copy_selected_columns', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage rcpp_build_mmutil_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_build_mmutil_index <- function(mtx_file, index_file = "") {
    .Call('_mmutilR_rcpp_build_mmutil_index', PACKAGE = 'mmutilR', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
rcpp_read_mmutil_index <- function(index_file) {
    .Call('_mmutilR_rcpp_read_mmutil_index', PACKAGE = 'mmutilR', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_check_index_tab <- function(mtx_file, index_tab) {
    .Call('_mmutilR_rcpp_check_index_tab', PACKAGE = 'mmutilR', mtx_file, index_tab)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::rcpp_simulate_poisson_data(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- mmutilR::rcpp_read_mmutil_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- mmutilR::rcpp_read_columns(data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
rcpp_read_columns <- function(mtx_file, memory_location, r_column_index) {
    .Call('_mmutilR_rcpp_read_columns', PACKAGE = 'mmutilR', mtx_file, memory_location, r_column_index)
}

#' Match the columns of two MTX files
#'
#' @param src_mtx source data file
#' @param tgt_mtx target data file
#' @param knn k-nearest neighbour
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization (default: 1e4)
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration (default: 5)
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#'
#' @return a list of source, target, distance
#'
#' @examples
#' ## Generate some data
#' rr <- rgamma(100, 1, 6) # 100 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' .matched <- mmutilR::rcpp_mmutil_match_files(dat$mtx, dat$mtx,
#'                                              knn=1, RANK=5)
#' ## Do they match well?
#' mean(.matched$src.index == .matched$tgt.index)
#' summary(.matched$dist)
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_match_files <- function(src_mtx, tgt_mtx, knn, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 10L, EM_TOL = 1e-4, LU_ITER = 5L, KNN_BILINK = 10L, KNN_NNLIST = 10L, row_weight_file = "") {
    .Call('_mmutilR_rcpp_mmutil_match_files', PACKAGE = 'mmutilR', src_mtx, tgt_mtx, knn, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, LU_ITER, KNN_BILINK, KNN_NNLIST, row_weight_file)
}

#' Create pseudo-bulk data by aggregating columns
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param r_cols column names
#' @param r_indv individual annotation
#' @param r_annot label annotation
#' @param r_lab_name label names
#' @param r_trt treatment assignment (default: NULL)
#' @param r_V SVD factors (default: NULL)
#' @param a0 hyperparameter for gamma(a0, b0) (default: 1e-4)
#' @param b0 hyperparameter for gamma(a0, b0) (default: 1e-4)
#' @param eps small number (default: 1e-8)
#' @param knn k-NN matching
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#' @param IMPUTE_BY_KNN imputation by kNN alone (default: false)
#'
#' @return a list of inference results
#'
#' @examples
#' options(stringsAsFactors = FALSE)
#' ## combine two different mu matrices
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm.1 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.1[1:10, ] <- rgamma(5, 1, .1)
#' mm.2 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.2[11:20, ] <- rgamma(5, 1, .1)
#' mm <- cbind(mm.1, mm.2)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' rows <- read.table(dat$row)$V1
#' cols <- read.table(dat$col)$V1
#' ## marker feature
#' markers <- list(
#'   annot.1 = list(
#'     ct1 = rows[1:10],
#'     ct2 = rows[11:20]
#'   )
#' )
#' ## annotation on the MTX file
#' out <- mmutilR::rcpp_annotate_columns(dat$row, dat$col,
#'        mtx_file = dat$mtx, pos_labels = markers)
#' annot <- out$annotation
#' ## prepare column to individual
#' .ind <- read.table(dat$indv, col.names = c("col", "ind"))
#' .annot.ind <- .ind$ind[match(annot$col, .ind$col)]
#' ## aggregate
#' agg <- mmutilR::rcpp_mmutil_aggregate(dat$mtx, dat$row, dat$col,
#'         annot$col, .annot.ind, annot$argmax, c("ct1", "ct2"))
#' ## show average marker features
#' print(round(agg$mean[1:20, ]))
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_aggregate <- function(mtx_file, row_file, col_file, r_cols, r_indv, r_annot, r_lab_name, r_trt = NULL, r_V = NULL, a0 = 1e-4, b0 = 1e-4, eps = 1e-8, knn = 10L, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, IMPUTE_BY_KNN = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_aggregate', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_cols, r_indv, r_annot, r_lab_name, r_trt, r_V, a0, b0, eps, knn, KNN_BILINK, KNN_NNLIST, NUM_THREADS, IMPUTE_BY_KNN)
}

#' Collect row-wise and column-wise statistics
#'
#' @param mtx_file data file
#' @return a list of stat vectors
#'
#' @examples
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' dat <- mmutilR::rcpp_simulate_poisson_data(mm, rr, "sim_test")
#' scr <- mmutilR::rcpp_compute_scores(dat$mtx)
#' A <- as.matrix(Matrix::readMM(dat$mtx))
#' colMeans(A)
#' scr$col.mean
#' rowMeans(A)
#' scr$row.mean
#'
rcpp_compute_scores <- function(mtx_file) {
    .Call('_mmutilR_rcpp_compute_scores', PACKAGE = 'mmutilR', mtx_file)
}

#' Simulation Poisson data
#'
#' @param Mu depth-adjusted mean matrix (M x n), M=#features and n=#indv
#' @param Rho column depth vector (N x 1), N=#cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::rcpp_simulate_poisson_data(mm, rr, data.hdr)
#' Y <- Matrix::readMM(.files$mtx)
#' print(Y)
#' A <- read.table(.files$indv, col.names = c("col", "ind"))
#' head(A)
#' unlink(list.files(pattern = data.hdr))
#'
rcpp_simulate_poisson_data <- function(mu, rho, output) {
    .Call('_mmutilR_rcpp_simulate_poisson_data', PACKAGE = 'mmutilR', mu, rho, output)
}

