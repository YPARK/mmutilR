# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' BBKNN(Batch-balancing kNN) adjustment of SVD factors
#'
#' @param r_svd_v (n x L) n number of data points
#' @param r_svd_u (m x L) m number of features (default: NULL)
#' @param r_svd_d (L x 1) singular values (default: NULL)
#' @param r_batches batch names (n x 1)
#' @param knn kNN parameter k
#' @param RECIPROCAL_MATCH do reciprocal match (default: TRUE)
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#' @param USE_SINGULAR_VALUES Weight factors by the corresponding SVs
#'
#' @return a list of (1) factors.adjusted (2) D (3) V (4) knn
#'
#' @details
#'
#' Build batch-balancing kNN graph based on (V * D) or V data.
#'
#'
rcpp_mmutil_bbknn <- function(r_svd_v, r_svd_u = NULL, r_svd_d = NULL, r_batches = NULL, knn = 10L, RECIPROCAL_MATCH = TRUE, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, USE_SINGULAR_VALUES = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_bbknn', PACKAGE = 'mmutilR', r_svd_v, r_svd_u, r_svd_d, r_batches, knn, RECIPROCAL_MATCH, KNN_BILINK, KNN_NNLIST, NUM_THREADS, USE_SINGULAR_VALUES)
}

#' BBKNN(Batch-balancing kNN)-adjusted SVD
#'
#' @param mtx_file data file (feature x n)
#' @param r_batches batch names (n x 1)
#' @param knn kNN parameter k
#' @param RANK SVD rank
#' @param RECIPROCAL_MATCH do reciprocal match (default: TRUE)
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default: 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 0)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#' @param BLOCK_SIZE number of columns per block
#' @param USE_SINGULAR_VALUES Weight factors by the corresponding SVs
#'
#' @return a list of (1) factors.adjusted (2) D (3) V (4) knn
#'
rcpp_mmutil_bbknn_mtx <- function(mtx_file, r_batches, knn, RANK, RECIPROCAL_MATCH = TRUE, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 0L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "", NUM_THREADS = 1L, BLOCK_SIZE = 10000L, USE_SINGULAR_VALUES = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_bbknn_mtx', PACKAGE = 'mmutilR', mtx_file, r_batches, knn, RANK, RECIPROCAL_MATCH, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file, NUM_THREADS, BLOCK_SIZE, USE_SINGULAR_VALUES)
}

#' Annotate columns by marker feature information
#'
#' @param row_file row file
#' @param col_file column file
#' @param pos_labels markers
#' @param neg_labels anti-markers
#' @param qc_labels feature-specific threshold
#' @param mtx_file data file
#' @param param_kappa_max
#'
#' @return a list of inference results
#'
#' @examples
#' options(stringsAsFactors = FALSE)
#' ## combine two different mu matrices
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm.1 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.1[1:10, ] <- rgamma(5, 1, .1)
#' mm.2 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.2[11:20, ] <- rgamma(5, 1, .1)
#' mm <- cbind(mm.1, mm.2)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' rows <- read.table(dat$row)$V1
#' cols <- read.table(dat$col)$V1
#' ## marker feature
#' markers <- list(
#'   annot.1 = list(
#'     ct1 = rows[1:10],
#'     ct2 = rows[11:20]
#'   )
#' )
#' ## annotation on the MTX file
#' out <- mmutilR::rcpp_mmutil_annotate_columns(
#'        row_file = dat$row, col_file = dat$col,
#'        mtx_file = dat$mtx, pos_labels = markers)
#' annot <- out$annotation
#' .pca <- mmutilR::rcpp_mmutil_pca(dat$mtx, 3, TAKE_LN = TRUE)
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' ## annotation on the PC results
#' out.2 <- mmutilR::rcpp_mmutil_annotate_columns(
#'          row_file = dat$row, col_file = dat$col,
#'          pos_labels = markers,
#'          r_U = .pca$U, r_D = .pca$D, r_V = .pca$V)
#' annot <- out.2$annotation
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_annotate_columns <- function(pos_labels, r_rows = NULL, r_cols = NULL, r_neg_labels = NULL, r_qc_labels = NULL, mtx_file = "", row_file = "", col_file = "", r_U = NULL, r_D = NULL, r_V = NULL, KAPPA_MAX = 100., TAKE_LN = FALSE, BATCH_SIZE = 10000L, EM_ITER = 100L, EM_TOL = 1e-4, VERBOSE = FALSE, DO_STD = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_annotate_columns', PACKAGE = 'mmutilR', pos_labels, r_rows, r_cols, r_neg_labels, r_qc_labels, mtx_file, row_file, col_file, r_U, r_D, r_V, KAPPA_MAX, TAKE_LN, BATCH_SIZE, EM_ITER, EM_TOL, VERBOSE, DO_STD)
}

#' Merge multiple 10x mtx file sets into one set
#'
#' @param r_headers file set headers
#' @param r_batches unique batch names for each header
#' @param r_mtx_files A list of mtx files
#' @param r_row_files A list of row files
#' @param r_col_files A list of col files
#' @param r_fixed_rows A list of rows/features
#' @param output output file header
#' @param nnz_cutoff number of non-zero cutoff for columns
#' @param delim delimiter in the column name
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' t1 <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "test1")
#' t2 <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "test2")
#' bats <- hdrs <- c("test1","test2")
#' t3 <- mmutilR::rcpp_mmutil_merge_file_sets(
#'                       hdrs, bats, output = "test3", nnz_cutoff = 0)
#' A1 <- Matrix::readMM(t1$mtx);
#' rownames(A1) <- unlist(read.table(gzfile(t1$row)))
#' A2 <- Matrix::readMM(t2$mtx)
#' rownames(A2) <- unlist(read.table(gzfile(t2$row)))
#' A3 <- Matrix::readMM(t3$mtx)
#' rownames(A3) <- unlist(read.table(gzfile(t3$row)))
#' print(cbind(A1, A2))
#' print(A3)
#' unlink(list.files(pattern = "test1"))
#' unlink(list.files(pattern = "test2"))
#' unlink(list.files(pattern = "test3"))
#'
rcpp_mmutil_merge_file_sets <- function(r_headers = NULL, r_batches = NULL, r_mtx_files = NULL, r_row_files = NULL, r_col_files = NULL, r_fixed_rows = NULL, output = "output", nnz_cutoff = 1, delim = "_", MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_merge_file_sets', PACKAGE = 'mmutilR', r_headers, r_batches, r_mtx_files, r_row_files, r_col_files, r_fixed_rows, output, nnz_cutoff, delim, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Take a subset of rows and create a new MTX file-set
#'
#' @description For the new mtx file, empty columns with only zero
#'   elements will be removed.
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected row names
#' @param output output
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' rownames(Y) <- read.table(src.files$row)$V1
#' print(Y)
#' sub.rows <- sort(read.table(src.files$row)$V1[sample(10,3)])
#' print(sub.rows)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_mmutil_copy_selected_rows(
#'                src.files$mtx,
#'                src.files$row,
#'                src.files$col,
#'                sub.rows,
#'                tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' rownames(Y) <- read.table(tgt.files$row)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_mmutil_copy_selected_rows <- function(mtx_file, row_file, col_file, r_selected, output, MAX_ROW_WORD = 100L, ROW_WORD_SEP = '@', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_copy_selected_rows', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Take a subset of columns and create a new MTX file-set
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected column names
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' colnames(Y) <- read.table(src.files$col)$V1
#' print(Y)
#' sub.cols <- sort(read.table(src.files$col)$V1[sample(20,3)])
#' print(sub.cols)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_mmutil_copy_selected_columns(
#'                          src.files$mtx,
#'                          src.files$row,
#'                          src.files$col,
#'                          sub.cols, tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_mmutil_copy_selected_columns <- function(mtx_file, row_file, col_file, r_selected, output, MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_copy_selected_columns', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output, MAX_COL_WORD, COL_WORD_SEP)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage rcpp_mmutil_build_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_mmutil_build_index <- function(mtx_file, index_file = "") {
    .Call('_mmutilR_rcpp_mmutil_build_index', PACKAGE = 'mmutilR', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
rcpp_mmutil_read_index <- function(index_file) {
    .Call('_mmutilR_rcpp_mmutil_read_index', PACKAGE = 'mmutilR', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_mmutil_check_index <- function(mtx_file, index_tab) {
    .Call('_mmutilR_rcpp_mmutil_check_index', PACKAGE = 'mmutilR', mtx_file, index_tab)
}

#' Just read the header information
#'
#' @param mtx_file data file
#'
#' @return info
#'
rcpp_mmutil_info <- function(mtx_file) {
    .Call('_mmutilR_rcpp_mmutil_info', PACKAGE = 'mmutilR', mtx_file)
}

#' Just read each row name per line
#'
#' @param row_file data file
#'
#' @return rownames
#'
rcpp_mmutil_rownames <- function(row_file, MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_') {
    .Call('_mmutilR_rcpp_mmutil_rownames', PACKAGE = 'mmutilR', row_file, MAX_ROW_WORD, ROW_WORD_SEP)
}

#' Just read each col name per line
#'
#' @param col_file data file
#'
#' @return colnames
#'
rcpp_mmutil_colnames <- function(col_file, MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_colnames', PACKAGE = 'mmutilR', col_file, MAX_COL_WORD, COL_WORD_SEP)
}

#' Write down sparse matrix to the disk
#' @param X sparse matrix
#' @param mtx_file file name
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
rcpp_mmutil_write_mtx <- function(X, mtx_file) {
    .Call('_mmutilR_rcpp_mmutil_write_mtx', PACKAGE = 'mmutilR', X, mtx_file)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return lists of rows, columns, values
#'
rcpp_mmutil_read_columns_sparse <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_mmutilR_rcpp_mmutil_read_columns_sparse', PACKAGE = 'mmutilR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- mmutilR::rcpp_mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- mmutilR::rcpp_mmutil_read_columns(
#'                  data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
rcpp_mmutil_read_columns <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_mmutilR_rcpp_mmutil_read_columns', PACKAGE = 'mmutilR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Match the columns of two MTX files
#'
#' @param src_mtx source data file
#' @param tgt_mtx target data file
#' @param knn k-nearest neighbour
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization (default: 1e4)
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration (default: 5)
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#' @param BLOCK_SIZE number of columns per block
#'
#' @return a list of source, target, distance
#'
#' @examples
#' ## Generate some data
#' rr <- rgamma(100, 1, 6) # 100 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' .matched <- mmutilR::rcpp_mmutil_match_files(dat$mtx, dat$mtx,
#'                                              knn=1, RANK=5)
#' ## Do they match well?
#' mean(.matched$src.index == .matched$tgt.index)
#' summary(.matched$dist)
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_match_files <- function(src_mtx, tgt_mtx, knn, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 10L, EM_TOL = 1e-4, LU_ITER = 5L, KNN_BILINK = 10L, KNN_NNLIST = 10L, row_weight_file = "", NUM_THREADS = 1L, BLOCK_SIZE = 10000L) {
    .Call('_mmutilR_rcpp_mmutil_match_files', PACKAGE = 'mmutilR', src_mtx, tgt_mtx, knn, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, LU_ITER, KNN_BILINK, KNN_NNLIST, row_weight_file, NUM_THREADS, BLOCK_SIZE)
}

#' Construct a kNN cell-cell interaction network and identify gene topics
#'
#' @param mtx_file data file (feature x n)
#' @param row_file row file (feature x 1)
#' @param col_file row file (n x 1)
#' @param latent_factor (n x K)
#' @param knn kNN parameter
#' @param output file header for resulting files
#'
#' @param CUTOFF expression present/absent call cutoff (default: 1e-2)
#' @param WEIGHTED include edge weights in feature calculation (default: TRUE)
#' @param MAXW maximum edge weight (default: 1)
#'
#' @param write_sample_network Do we want sample inc/adj? (default: FALSE)
#' @param output_sample_incidence file header for sample inc (default: NULL)
#' @param output_sample_incidence file header for sample adj (default: NULL)
#'
#' @param r_batches batch names (n x 1, default: NULL)
#'
#' @param CUTOFF expression present/absent call cutoff (default: 0)
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#'
#' @param MAX_ROW_WORD maximum words per line in `row_file`
#' @param ROW_WORD_SEP word separation character to replace white space
#' @param MAX_COL_WORD maximum words per line in `col_file`
#' @param COL_WORD_SEP word separation character to replace white space
#'
#' @return feature.incidence, sample.incidence, sample.adjacency
#'
rcpp_mmutil_network_topic_data <- function(mtx_file, row_file, col_file, latent_factor, knn, output, write_sample_network = FALSE, output_sample_incidence = NULL, output_sample_adjacency = NULL, r_batches = NULL, CUTOFF = 1e-4, WEIGHTED = TRUE, MAXW = 1, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_network_topic_data', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, latent_factor, knn, output, write_sample_network, output_sample_incidence, output_sample_adjacency, r_batches, CUTOFF, WEIGHTED, MAXW, KNN_BILINK, KNN_NNLIST, NUM_THREADS, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Create pseudo-bulk data for pairwise comparisons
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param r_indv membership for the cells (\code{r_cols})
#' @param r_V SVD factors
#' @param r_cols cell (col) names (if we want to take a subset)
#' @param r_annot label annotation for the (\code{r_cols})
#' @param r_lab_name label names (default: everything in \code{r_annot})
#' @param r_annot_mat label annotation matrix (cell x type) (default: NULL)
#' @param a0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param b0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param eps small number (default: 1e-8)
#' @param knn_cell k-NN matching between cells
#' @param knn_indv k-NN matching between individuals
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#' @param IMPUTE_BY_KNN imputation by kNN alone (default: TRUE)
#'
#' @return a list of inference results
#'
rcpp_mmutil_aggregate_pairwise <- function(mtx_file, row_file, col_file, r_indv, r_V, r_cols = NULL, r_annot = NULL, r_annot_mat = NULL, r_lab_name = NULL, a0 = 1.0, b0 = 1.0, eps = 1e-8, knn_cell = 10L, knn_indv = 1L, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, IMPUTE_BY_KNN = TRUE, MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_aggregate_pairwise', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_indv, r_V, r_cols, r_annot, r_annot_mat, r_lab_name, a0, b0, eps, knn_cell, knn_indv, KNN_BILINK, KNN_NNLIST, NUM_THREADS, IMPUTE_BY_KNN, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Create pseudo-bulk data by aggregating columns
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param r_cols cell (col) names
#' @param r_indv membership for the cells (\code{r_cols})
#' @param r_annot label annotation for the (\code{r_cols})
#' @param r_lab_name label names (default: everything in \code{r_annot})
#' @param r_annot_mat label annotation matrix (cell x type) (default: NULL)
#' @param r_trt treatment assignment (default: NULL)
#' @param r_V SVD factors (default: NULL)
#' @param a0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param b0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param eps small number (default: 1e-8)
#' @param knn k-NN matching
#' @param KNN_BILINK num. of bidirectional links (default: 10)
#' @param KNN_NNLIST num. of nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#' @param IMPUTE_BY_KNN imputation by kNN alone (default: TRUE)
#'
#' @return a list of inference results
#'
rcpp_mmutil_aggregate <- function(mtx_file, row_file, col_file, r_cols = NULL, r_indv = NULL, r_annot = NULL, r_annot_mat = NULL, r_lab_name = NULL, r_trt = NULL, r_V = NULL, a0 = 1.0, b0 = 1.0, eps = 1e-8, knn = 10L, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, IMPUTE_BY_KNN = TRUE, MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_aggregate', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_cols, r_indv, r_annot, r_annot_mat, r_lab_name, r_trt, r_V, a0, b0, eps, knn, KNN_BILINK, KNN_NNLIST, NUM_THREADS, IMPUTE_BY_KNN, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Collect row-wise and column-wise statistics
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#'
#' @return a list of stat vectors
#'
#' @examples
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' scr <- mmutilR::rcpp_mmutil_compute_scores(dat$mtx)
#' A <- as.matrix(Matrix::readMM(dat$mtx))
#' colMeans(A)
#' scr$col$mean
#' rowMeans(A)
#' scr$row$mean
#'
rcpp_mmutil_compute_scores <- function(mtx_file, row_file = NULL, col_file = NULL, MAX_ROW_WORD = 2L, ROW_WORD_SEP = '_', MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_compute_scores', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, MAX_ROW_WORD, ROW_WORD_SEP, MAX_COL_WORD, COL_WORD_SEP)
}

#' Simulate sparse counting data with a mixture of Poisson parameters
#'
#'
#' @param r_mu_list a list of gene x individual matrices
#' @param Ncell the total number of cells (may not make it if too sparse)
#' @param output a file header string for output files
#' @param dir_alpha a parameter for Dirichlet(alpha * [1, ..., 1])
#' @param gam_alpha a parameter for Gamma(alpha, beta)
#' @param gam_beta a parameter for Gamma(alpha, beta)
#' @param rseed random seed
#'
rcpp_mmutil_simulate_poisson_mixture <- function(r_mu_list, Ncell, output, dir_alpha = 1.0, gam_alpha = 2.0, gam_beta = 2.0, rseed = 42L, MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_simulate_poisson_mixture', PACKAGE = 'mmutilR', r_mu_list, Ncell, output, dir_alpha, gam_alpha, gam_beta, rseed, MAX_COL_WORD, COL_WORD_SEP)
}

#' Simulation Poisson data based on Mu
#'
#' M= num. of features and n= num. of indv
#'
#' @param mu depth-adjusted mean matrix (M x n)
#' @param rho column depth vector (N x 1), N= num. of cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#' @param r_indv N x 1 individual membership (1-based, [1 .. n])
#' @param rseed random seed
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
rcpp_mmutil_simulate_poisson <- function(mu, rho, output, r_indv = NULL, rseed = 42L, MAX_COL_WORD = 100L, COL_WORD_SEP = '@') {
    .Call('_mmutilR_rcpp_mmutil_simulate_poisson', PACKAGE = 'mmutilR', mu, rho, output, r_indv, rseed, MAX_COL_WORD, COL_WORD_SEP)
}

#' Approximate SVD
#'
#' @param mtx_file data file (feature x n)
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#' @param BLOCK_SIZE number of columns per block
#'
#' @return a list of (1) U (2) D (3) V
#'
#' @examples
#' ## Generate some data
#' set.seed(1)
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' .dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' .pc <- mmutilR::rcpp_mmutil_svd(.dat$mtx, 3, TAKE_LN = FALSE)
#' .ind <- read.table(.dat$indv)
#' .col <- unlist(read.table(.dat$col))
#' .ind <- .ind[match(.col, .ind$V1), ]
#' plot(.pc$V[, 1], .pc$V[, 2], col = .ind$V2,
#'      xlab = "PC1", ylab = "PC2")
#' plot(.pc$V[, 2], .pc$V[, 3], col = .ind$V2,
#'      xlab = "PC2", ylab = "PC3")
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_svd <- function(mtx_file, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 0L, EM_TOL = 1e-4, LU_ITER = 5L, row_weight_file = "", NUM_THREADS = 1L, BLOCK_SIZE = 10000L) {
    .Call('_mmutilR_rcpp_mmutil_svd', PACKAGE = 'mmutilR', mtx_file, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, LU_ITER, row_weight_file, NUM_THREADS, BLOCK_SIZE)
}

#' Build sparse matrix from triplets
#'
#' @param A_ij_list list(src.index, tgt.index, [weights])
#' @param Nrow number of rows
#' @param Ncol number of columns
#' @param symmetrize symmetrize A matrix
#'
#' @return a sparse matrix A
#'
rcpp_build_sparse_mat <- function(A_ij_list, Nrow, Ncol, symmetrize = TRUE) {
    .Call('_mmutilR_rcpp_build_sparse_mat', PACKAGE = 'mmutilR', A_ij_list, Nrow, Ncol, symmetrize)
}

