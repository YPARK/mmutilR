# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximate PCA
#'
#' @param mtx_file data file (feature x n)
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param row_weight_file row-wise weight file
#'
#' @return a list of (1) U (2) D (3) V
#'
#' @examples
#' ## Generate some data
#' set.seed(1)
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' .dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' .pc <- mmutilR::rcpp_mmutil_pca(.dat$mtx, 3, TAKE_LN = FALSE)
#' .ind <- read.table(.dat$indv)
#' .col <- unlist(read.table(.dat$col))
#' .ind <- .ind[match(.col, .ind$V1), ]
#' plot(.pc$V[, 1], .pc$V[, 2], col = .ind$V2,
#'      xlab = "PC1", ylab = "PC2")
#' plot(.pc$V[, 2], .pc$V[, 3], col = .ind$V2,
#'      xlab = "PC2", ylab = "PC3")
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_pca <- function(mtx_file, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 0L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "") {
    .Call('_mmutilR_rcpp_mmutil_pca', PACKAGE = 'mmutilR', mtx_file, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file)
}

#' BBKNN(Batch-balancing kNN)-adjusted PCA
#'
#' @param mtx_file data file (feature x n)
#' @param r_batches batch names (n x 1)
#' @param knn kNN parameter k
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#'
#' @return a list of (1) factors.adjusted (2) U (3) D (4) V
#'
#' @examples
#' ## Generate some data
#' set.seed(1)
#' .sim <- mmutilR::simulate_gamma_glm(nind = 5, ncell.ind = 1000)
#' .dat <- mmutilR::rcpp_mmutil_simulate_poisson(.sim$obs.mu,
#'                                               .sim$rho,
#'                                               "sim_test")
#' .ind <- read.table(.dat$indv)
#' .col <- unlist(read.table(.dat$col))
#' .ind <- .ind[match(.col, .ind$V1), ]
#' .bbknn <- mmutilR::rcpp_mmutil_bbknn_pca(.dat$mtx,
#'                   r_batches = .ind$V2,
#'                   knn = 10, RANK = 3, TAKE_LN = TRUE)
#' plot(.bbknn$V[, 1], .bbknn$V[, 2], col = .ind$V2,
#'      xlab = "PC1", ylab = "PC2", main = "no BBKNN")
#' plot(.bbknn$factors.adjusted[, 1], .bbknn$factors.adjusted[, 2],
#'      col = .ind$V2,
#'      xlab = "PC1 (BBKNN)", ylab = "PC2 (BBKNN)")
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_bbknn_pca <- function(mtx_file, r_batches, knn, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 0L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "", NUM_THREADS = 1L) {
    .Call('_mmutilR_rcpp_mmutil_bbknn_pca', PACKAGE = 'mmutilR', mtx_file, r_batches, knn, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file, NUM_THREADS)
}

#' Annotate columns by marker feature information
#'
#' @param row_file row file
#' @param col_file column file
#' @param pos_labels markers
#' @param neg_labels anti-markers
#' @param qc_labels feature-specific threshold
#' @param mtx_file data file
#' @param param_kappa_max
#'
#' @return a list of inference results
#'
#' @examples
#' options(stringsAsFactors = FALSE)
#' ## combine two different mu matrices
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm.1 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.1[1:10, ] <- rgamma(5, 1, .1)
#' mm.2 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.2[11:20, ] <- rgamma(5, 1, .1)
#' mm <- cbind(mm.1, mm.2)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' rows <- read.table(dat$row)$V1
#' cols <- read.table(dat$col)$V1
#' ## marker feature
#' markers <- list(
#'   annot.1 = list(
#'     ct1 = rows[1:10],
#'     ct2 = rows[11:20]
#'   )
#' )
#' ## annotation on the MTX file
#' out <- mmutilR::rcpp_mmutil_annotate_columns(
#'        row_file = dat$row, col_file = dat$col,
#'        mtx_file = dat$mtx, pos_labels = markers)
#' annot <- out$annotation
#' .pca <- mmutilR::rcpp_mmutil_pca(dat$mtx, 3, TAKE_LN = TRUE)
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' ## annotation on the PC results
#' out.2 <- mmutilR::rcpp_mmutil_annotate_columns(
#'          row_file = dat$row, col_file = dat$col,
#'          pos_labels = markers,
#'          r_U = .pca$U, r_D = .pca$D, r_V = .pca$V)
#' annot <- out.2$annotation
#' out.df <- data.frame(col = as.integer(annot$col),
#'                      argmax = annot$argmax)
#' out.df <- cbind(out.df, PC=.pca$V)
#' plot(out.df$PC.1, out.df$PC.2, xlab = "PC1", ylab = "PC2")
#' ct1 <- which(out.df$argmax == "ct1")
#' points(out.df$PC.1[ct1], out.df$PC.2[ct1], pch = 19, col = 2)
#' ct2 <- which(out.df$argmax == "ct2")
#' points(out.df$PC.1[ct2], out.df$PC.2[ct2], pch = 19, col = 3)
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_annotate_columns <- function(pos_labels, r_rows = NULL, r_cols = NULL, r_neg_labels = NULL, r_qc_labels = NULL, mtx_file = "", row_file = "", col_file = "", r_U = NULL, r_D = NULL, r_V = NULL, KAPPA_MAX = 100., TAKE_LN = FALSE, BATCH_SIZE = 10000L, EM_ITER = 100L, EM_TOL = 1e-4, VERBOSE = FALSE, DO_STD = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_annotate_columns', PACKAGE = 'mmutilR', pos_labels, r_rows, r_cols, r_neg_labels, r_qc_labels, mtx_file, row_file, col_file, r_U, r_D, r_V, KAPPA_MAX, TAKE_LN, BATCH_SIZE, EM_ITER, EM_TOL, VERBOSE, DO_STD)
}

#' Cell type deconvolution of bulk data based on single-cell data
#'
#' Salamander (semi-supervised annotation of latent states by marker
#' gene-derived regression model)
#'
rcpp_mmutil_deconvolve_svd <- function(mtx_file = "", row_file = "", col_file = "", r_U = NULL, r_D = NULL, r_V = NULL, r_rows = NULL, r_cols = NULL, TAKE_LN = FALSE, VERBOSE = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_deconvolve_svd', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_U, r_D, r_V, r_rows, r_cols, TAKE_LN, VERBOSE)
}

#' Merge multiple 10x mtx file sets into one set
#'
#' @param r_headers file set headers
#' @param r_batches unique batch names for each header
#' @param r_mtx A list of mtx files
#' @param r_row A list of row files
#' @param r_col A list of col files
#' @param output output file header
#' @param nnz_cutoff number of non-zero cutoff for columns
#' @param delim delimiter in the column name
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' t1 <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "test1")
#' t2 <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "test2")
#' bats <- hdrs <- c("test1","test2")
#' t3 <- mmutilR::rcpp_mmutil_merge_file_sets(
#'                       hdrs, bats, "test3", 0)
#' A1 <- Matrix::readMM(t1$mtx);
#' rownames(A1) <- unlist(read.table(gzfile(t1$row)))
#' A2 <- Matrix::readMM(t2$mtx)
#' rownames(A2) <- unlist(read.table(gzfile(t2$row)))
#' A3 <- Matrix::readMM(t3$mtx)
#' rownames(A3) <- unlist(read.table(gzfile(t3$row)))
#' print(cbind(A1, A2))
#' print(A3)
#' unlink(list.files(pattern = "test1"))
#' unlink(list.files(pattern = "test2"))
#' unlink(list.files(pattern = "test3"))
#'
rcpp_mmutil_merge_file_sets <- function(r_headers = NULL, r_batches = NULL, r_mtx = NULL, r_row = NULL, r_col = NULL, output = "output", nnz_cutoff = 1, delim = "_") {
    .Call('_mmutilR_rcpp_mmutil_merge_file_sets', PACKAGE = 'mmutilR', r_headers, r_batches, r_mtx, r_row, r_col, output, nnz_cutoff, delim)
}

#' Take a subset of rows and create a new MTX file-set
#'
#' @description For the new mtx file, empty columns with only zero
#'   elements will be removed.
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected row names
#' @param output output
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' rownames(Y) <- read.table(src.files$row)$V1
#' print(Y)
#' sub.rows <- sort(read.table(src.files$row)$V1[sample(10,3)])
#' print(sub.rows)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_mmutil_copy_selected_rows(
#'                src.files$mtx,
#'                src.files$row,
#'                src.files$col,
#'                sub.rows,
#'                tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' rownames(Y) <- read.table(tgt.files$row)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_mmutil_copy_selected_rows <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_mmutilR_rcpp_mmutil_copy_selected_rows', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output)
}

#' Take a subset of columns and create a new MTX file-set
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected column names
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' colnames(Y) <- read.table(src.files$col)$V1
#' print(Y)
#' sub.cols <- sort(read.table(src.files$col)$V1[sample(20,3)])
#' print(sub.cols)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutilR::rcpp_mmutil_copy_selected_columns(
#'                          src.files$mtx,
#'                          src.files$row,
#'                          src.files$col,
#'                          sub.cols, tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
rcpp_mmutil_copy_selected_columns <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_mmutilR_rcpp_mmutil_copy_selected_columns', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_selected, output)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage rcpp_mmutil_build_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_mmutil_build_index <- function(mtx_file, index_file = "") {
    .Call('_mmutilR_rcpp_mmutil_build_index', PACKAGE = 'mmutilR', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
rcpp_mmutil_read_index <- function(index_file) {
    .Call('_mmutilR_rcpp_mmutil_read_index', PACKAGE = 'mmutilR', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
rcpp_mmutil_check_index <- function(mtx_file, index_tab) {
    .Call('_mmutilR_rcpp_mmutil_check_index', PACKAGE = 'mmutilR', mtx_file, index_tab)
}

#' Just read the header information
#'
#' @param mtx_file data file
#'
#' @return info
#'
rcpp_mmutil_info <- function(mtx_file) {
    .Call('_mmutilR_rcpp_mmutil_info', PACKAGE = 'mmutilR', mtx_file)
}

#' Write down sparse matrix to the disk
#' @param X_
#' @param output
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
rcpp_mmutil_write_mtx <- function(X, mtx_file) {
    .Call('_mmutilR_rcpp_mmutil_write_mtx', PACKAGE = 'mmutilR', X, mtx_file)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return lists of rows, columns, values
#'
rcpp_mmutil_read_columns_sparse <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_mmutilR_rcpp_mmutil_read_columns_sparse', PACKAGE = 'mmutilR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- mmutilR::rcpp_mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- mmutilR::rcpp_mmutil_read_columns(
#'                  data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
rcpp_mmutil_read_columns <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_mmutilR_rcpp_mmutil_read_columns', PACKAGE = 'mmutilR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Match the columns of two MTX files
#'
#' @param src_mtx source data file
#' @param tgt_mtx target data file
#' @param knn k-nearest neighbour
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization (default: 1e4)
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration (default: 5)
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#'
#' @return a list of source, target, distance
#'
#' @examples
#' ## Generate some data
#' rr <- rgamma(100, 1, 6) # 100 cells
#' mm <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' .matched <- mmutilR::rcpp_mmutil_match_files(dat$mtx, dat$mtx,
#'                                              knn=1, RANK=5)
#' ## Do they match well?
#' mean(.matched$src.index == .matched$tgt.index)
#' summary(.matched$dist)
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_match_files <- function(src_mtx, tgt_mtx, knn, RANK, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 10L, EM_TOL = 1e-4, LU_ITER = 5L, KNN_BILINK = 10L, KNN_NNLIST = 10L, row_weight_file = "", NUM_THREADS = 1L) {
    .Call('_mmutilR_rcpp_mmutil_match_files', PACKAGE = 'mmutilR', src_mtx, tgt_mtx, knn, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, LU_ITER, KNN_BILINK, KNN_NNLIST, row_weight_file, NUM_THREADS)
}

#' Clustering columns of the network mtx file (feature incidence matrix)
#'
#' @param mtx_file data file (feature x edge)
#' @param row_file row file (feature x 1)
#' @param col_file col file (sample x 1)
#' @param output a file header for result/temporary files
#' @param nnz_cutoff Only consider edge with NNZ >= nnz_cutoff (default: 1)
#'
rcpp_mmutil_network_edge_cluster <- function(mtx_file, row_file, col_file, output, num_clust = 10L, num_gibbs = 100L, num_burnin = 100L, nnz_cutoff = 1L, A0 = 1., B0 = 1., Dir0 = 1., verbose = TRUE) {
    .Call('_mmutilR_rcpp_mmutil_network_edge_cluster', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, output, num_clust, num_gibbs, num_burnin, nnz_cutoff, A0, B0, Dir0, verbose)
}

#' Construct a kNN cell-cell interaction network and identify gene topics
#'
#' @param mtx_file data file (feature x n)
#' @param knn kNN parameter
#' @param output a file header for resulting files
#' @param CUTOFF expression present/absent call cutoff (default: 1e-2)
#' @param WEIGHTED keep weights for edges (default: FALSE)
#' @param MAXW maximum weight (default: 1)
#' @param r_batches batch info (default: NULL)
#' @param r_U SVD for kNN network construction (X = UDV')
#' @param r_D SVD for kNN network construction (X = UDV')
#' @param r_V SVD for kNN network construction (X = UDV')
#' @param RANK SVD rank
#' @param TAKE_LN take log(1 + x) trans or not
#' @param TAU regularization parameter (default = 1)
#' @param COL_NORM column normalization for SVD
#' @param EM_ITER EM iteration for factorization (default: 10)
#' @param EM_TOL EM convergence (default: 1e-4)
#' @param LU_ITER LU iteration
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param row_weight_file row-wise weight file
#' @param NUM_THREADS number of threads for multi-core processing
#'
#' @return feature.incidence, sample.incidence, edges, adjacency matrix files
#'
#' @examples
#' ## Generate some data
#' set.seed(1)
#' .sim <- mmutilR::simulate_gamma_glm(nind = 3, ncell.ind = 10, ngene = 20)
#' .dat <- mmutilR::rcpp_mmutil_simulate_poisson(.sim$obs.mu,
#'                                               .sim$rho,
#'                                               "sim_test")
#' .data <- mmutilR::rcpp_mmutil_network_topic_data(.dat$mtx,
#'                   knn = 3, output = "net_data",
#'                   RANK = 3, TAKE_LN = TRUE)
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#' unlink(list.files(pattern = "net_data"))
#'
rcpp_mmutil_network_topic_data <- function(mtx_file, knn, output, CUTOFF = 1e-2, WEIGHTED = FALSE, MAXW = 1, col_file = "", row_file = "", r_batches = NULL, r_U = NULL, r_D = NULL, r_V = NULL, RANK = 0L, TAKE_LN = TRUE, TAU = 1., COL_NORM = 1e4, EM_ITER = 0L, EM_TOL = 1e-4, KNN_BILINK = 10L, KNN_NNLIST = 10L, LU_ITER = 5L, row_weight_file = "", NUM_THREADS = 1L) {
    .Call('_mmutilR_rcpp_mmutil_network_topic_data', PACKAGE = 'mmutilR', mtx_file, knn, output, CUTOFF, WEIGHTED, MAXW, col_file, row_file, r_batches, r_U, r_D, r_V, RANK, TAKE_LN, TAU, COL_NORM, EM_ITER, EM_TOL, KNN_BILINK, KNN_NNLIST, LU_ITER, row_weight_file, NUM_THREADS)
}

#' Create pseudo-bulk data by aggregating columns
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param r_cols cell (col) names
#' @param r_indv membership for the cells (\code{r_cols})
#' @param r_annot label annotation for the (\code{r_cols})
#' @param r_lab_name label names (default: everything in \code{r_annot})
#' @param r_annot_mat label annotation matrix (cell x type) (default: NULL)
#' @param r_trt treatment assignment (default: NULL)
#' @param r_V SVD factors (default: NULL)
#' @param a0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param b0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param eps small number (default: 1e-8)
#' @param knn k-NN matching
#' @param KNN_BILINK # of bidirectional links (default: 10)
#' @param KNN_NNLIST # nearest neighbor lists (default: 10)
#' @param NUM_THREADS number of threads for multi-core processing
#' @param IMPUTE_BY_KNN imputation by kNN alone (default: false)
#'
#' @return a list of inference results
#'
#' @examples
#' options(stringsAsFactors = FALSE)
#' ## combine two different mu matrices
#' set.seed(1)
#' rr <- rgamma(1000, 1, 1) # 1000 cells
#' mm.1 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.1[1:10, ] <- rgamma(5, 1, .1)
#' mm.2 <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' mm.2[11:20, ] <- rgamma(5, 1, .1)
#' mm <- cbind(mm.1, mm.2)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' rows <- read.table(dat$row)$V1
#' cols <- read.table(dat$col)$V1
#' ## marker feature
#' markers <- list(
#'   annot.1 = list(
#'     ct1 = rows[1:10],
#'     ct2 = rows[11:20]
#'   )
#' )
#' ## annotation on the MTX file
#' out <- mmutilR::rcpp_mmutil_annotate_columns(
#'        row_file = dat$row, col_file = dat$col,
#'        mtx_file = dat$mtx, pos_labels = markers)
#' annot <- out$annotation
#' ## prepare column to individual
#' .ind <- read.table(dat$indv, col.names = c("col", "ind"))
#' .annot.ind <- .ind$ind[match(annot$col, .ind$col)]
#' ## aggregate
#' agg <- mmutilR::rcpp_mmutil_aggregate(dat$mtx, dat$row, dat$col,
#'         annot$col, .annot.ind, annot$argmax, c("ct1", "ct2"))
#' ## show average marker features
#' print(round(agg$mean[1:20, ]))
#' unlink(list.files(pattern = "sim_test"))
#' ## Case-control simulation
#' .sim <- mmutilR::simulate_gamma_glm()
#' .dat <- mmutilR::rcpp_mmutil_simulate_poisson(.sim$obs.mu,
#'                                              .sim$rho,
#'                                              "sim_test")
#' ## find column-wise annotation
#' .annot <- read.table(.dat$indv,
#'                      col.names = c("col", "ind"))
#' .annot$trt <- .sim$W[match(.annot$ind, 1:length(.sim$W))]
#' .annot$ct <- "ct1"
#' ## simple PCA
#' .pca <- mmutilR::rcpp_mmutil_pca(.dat$mtx, 10)
#' .agg <- mmutilR::rcpp_mmutil_aggregate(mtx_file = .dat$mtx,
#'                                        row_file = .dat$row,
#'                                        col_file = .dat$col,
#'                                        r_cols = .annot$col,
#'                                        r_indv = .annot$ind,
#'                                        r_annot = .annot$ct,
#'                                        r_lab_name = "ct1",
#'                                        r_trt = .annot$trt,
#'                                        r_V = .pca$V,
#'                                        knn = 50,
#'                                        IMPUTE_BY_KNN = TRUE)
#' par(mfrow=c(1,3))
#' for(k in sample(.sim$causal, 3)) {
#'     y0 <- .agg$resid.mu[k, .sim$W == 0]
#'     y1 <- .agg$resid.mu[k, .sim$W == 1]
#'     boxplot(y0, y1)
#' }
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_aggregate <- function(mtx_file, row_file, col_file, r_cols = NULL, r_indv = NULL, r_annot = NULL, r_annot_mat = NULL, r_lab_name = NULL, r_trt = NULL, r_V = NULL, a0 = 1.0, b0 = 1.0, eps = 1e-8, knn = 10L, KNN_BILINK = 10L, KNN_NNLIST = 10L, NUM_THREADS = 1L, IMPUTE_BY_KNN = FALSE) {
    .Call('_mmutilR_rcpp_mmutil_aggregate', PACKAGE = 'mmutilR', mtx_file, row_file, col_file, r_cols, r_indv, r_annot, r_annot_mat, r_lab_name, r_trt, r_V, a0, b0, eps, knn, KNN_BILINK, KNN_NNLIST, NUM_THREADS, IMPUTE_BY_KNN)
}

#' Collect row-wise and column-wise statistics
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#'
#' @return a list of stat vectors
#'
#' @examples
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' dat <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, "sim_test")
#' scr <- mmutilR::rcpp_mmutil_compute_scores(dat$mtx)
#' A <- as.matrix(Matrix::readMM(dat$mtx))
#' colMeans(A)
#' scr$col$mean
#' rowMeans(A)
#' scr$row$mean
#'
rcpp_mmutil_compute_scores <- function(mtx_file, row_file = NULL, col_file = NULL) {
    .Call('_mmutilR_rcpp_mmutil_compute_scores', PACKAGE = 'mmutilR', mtx_file, row_file, col_file)
}

#' Simulation Poisson data
#'
#' @param Mu depth-adjusted mean matrix (M x n), M=#features and n=#indv
#' @param Rho column depth vector (N x 1), N=#cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#' @param r_indv N x 1 individual membership (1-based, [1 .. n])
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::rcpp_mmutil_simulate_poisson(mm, rr, data.hdr)
#' Y <- Matrix::readMM(.files$mtx)
#' print(Y)
#' A <- read.table(.files$indv, col.names = c("col", "ind"))
#' head(A)
#' unlink(list.files(pattern = data.hdr))
#'
rcpp_mmutil_simulate_poisson <- function(mu, rho, output, r_indv = NULL) {
    .Call('_mmutilR_rcpp_mmutil_simulate_poisson', PACKAGE = 'mmutilR', mu, rho, output, r_indv)
}

#' Compute RNA velocity comparing the spliced and unspliced
#' at the pseudo-bulk level (individual and cell type)
#'
#' @param spliced_mtx_file spliced data file
#' @param unspliced_mtx_file unspliced data file
#' @param spliced_col_file column file for the spliced mtx
#' @param unspliced_col_file column file for the unspliced
#' @param row_file row file (shared)
#' @param col_file column file (shared)
#' @param r_cols cell (col) names
#' @param r_indv membership for the cells (\code{r_cols})
#' @param r_annot label annotation for the (\code{r_cols})
#' @param r_lab_name label names (default: everything in \code{r_annot})
#' @param a0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param b0 hyperparameter for gamma(a0, b0) (default: 1)
#' @param MAX_ITER maximum iteration for the delta estimation
#' @param TOL tolerance level for convergence test
#' @param NUM_THREADS number of threads (useful for many individuals)
#'
#' @return a list of inference results
#'
#' @examples
#'
#' options(stringsAsFactors = FALSE)
#' set.seed(1)
#' nn <- 3000
#' rr <- rgamma(nn, 6.25, 6.25) # 1000 cells
#' uu <- matrix(rgamma(100 * 3, 1, 1), 100, 3)
#' dd <- matrix(rgamma(100 * 3, 1, 1/10), 100, 3)
#' ss <- uu / (dd + 1e-2)
#' ind <- sample(3, nn, replace=TRUE)
#'
#' spliced <- mmutilR::rcpp_mmutil_simulate_poisson(ss, rr,
#'                                                  "sim_test_raw_spliced",
#'                                                  r_indv = ind)
#'
#' unspliced <- mmutilR::rcpp_mmutil_simulate_poisson(uu, rr,
#'                                                    "sim_test_raw_unspliced",
#'                                                    r_indv = ind)
#'
#' .col <- sort(intersect(read.table(spliced$col)$V1,
#'                        read.table(unspliced$col)$V1))
#'
#' spliced <- mmutilR::rcpp_mmutil_copy_selected_columns(
#'                         spliced$mtx,
#'                         spliced$row,
#'                         spliced$col,
#'                         .col,
#'                         "sim_test_spliced")
#'
#' unspliced <- mmutilR::rcpp_mmutil_copy_selected_columns(
#'                         unspliced$mtx,
#'                         unspliced$row,
#'                         unspliced$col,
#'                         .col,
#'                         "sim_test_unspliced")
#'
#' .out <- mmutilR::rcpp_mmutil_aggregate_velocity(
#'                      spliced$mtx,
#'                      unspliced$mtx,
#'                      spliced$row,
#'                      spliced$col,
#'                      r_col = .col,
#'                      r_indv = ind[.col],
#'                      a0 = 1, b0 = 1)
#'
#' .agg.u <- mmutilR::rcpp_mmutil_aggregate(
#'                        unspliced$mtx,
#'                        unspliced$row,
#'                        unspliced$col,
#'                        r_col = .col,
#'                        r_indv = ind[.col],
#'                        a0 = 1, b0 = 1)
#'
#' .agg.s <- mmutilR::rcpp_mmutil_aggregate(
#'                        spliced$mtx,
#'                        spliced$row,
#'                        spliced$col,
#'                        r_col = .col,
#'                        r_indv = ind[.col],
#'                        a0 = 1, b0 = 1)
#'
#' par(mfrow=c(1, ncol(.out$delta)))
#' for(k in 1:ncol(.out$delta)){
#'     plot(.agg.u$mu[,k]/.agg.s$mu[,k],
#'          .out$delta[,k],
#'          log = "xy",
#'          pch = 1,
#'          ylab = "predicted",
#'          xlab = "true")
#'     abline(a=0, b=1, col=3)
#' }
#'
#'
#' ## clean up temp directory
#' unlink(list.files(pattern = "sim_test"))
#'
rcpp_mmutil_aggregate_velocity <- function(spliced_mtx_file, unspliced_mtx_file, row_file, col_file, r_cols = NULL, r_indv = NULL, r_annot = NULL, r_lab_name = NULL, a0 = 1.0, b0 = 1.0, MAX_ITER = 100L, TOL = 1e-4, NUM_THREADS = 1L) {
    .Call('_mmutilR_rcpp_mmutil_aggregate_velocity', PACKAGE = 'mmutilR', spliced_mtx_file, unspliced_mtx_file, row_file, col_file, r_cols, r_indv, r_annot, r_lab_name, a0, b0, MAX_ITER, TOL, NUM_THREADS)
}

